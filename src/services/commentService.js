/**
 * ğŸ’¬ ServiÃ§o de ComentÃ¡rios - IF Wave
 * Gerencia sistema completo de comentÃ¡rios em posts, stories e enquetes
 */

class CommentService {
  constructor() {
    this.comments = this.loadComments();
    this.userSettings = this.loadUserSettings();
  }

  // Carrega comentÃ¡rios do localStorage
  loadComments() {
    const stored = localStorage.getItem('if_wave_comments');
    return stored ? JSON.parse(stored) : {};
  }

  // Carrega configuraÃ§Ãµes do usuÃ¡rio
  loadUserSettings() {
    const stored = localStorage.getItem('if_wave_comment_settings');
    return stored ? JSON.parse(stored) : {
      notifications: true,
      autoTranslate: false,
      hideInappropriate: true
    };
  }

  // Salva comentÃ¡rios no localStorage
  saveComments() {
    localStorage.setItem('if_wave_comments', JSON.stringify(this.comments));
  }

  // Adiciona um novo comentÃ¡rio
  addComment(postId, userId, text, parentCommentId = null) {
    if (!postId || !userId || !text?.trim()) {
      throw new Error('PostId, UserId e texto sÃ£o obrigatÃ³rios');
    }

    const commentId = this.generateCommentId();
    const now = new Date().toISOString();
    
    const comment = {
      id: commentId,
      postId,
      userId,
      text: text.trim(),
      parentCommentId,
      timestamp: now,
      edited: false,
      editedAt: null,
      likes: 0,
      replies: [],
      isHidden: false,
      reported: false,
      metadata: {
        device: this.getDeviceInfo(),
        ipHash: this.getIpHash(),
        userAgent: navigator.userAgent.substring(0, 100)
      }
    };

    // Inicializa array de comentÃ¡rios do post se nÃ£o existir
    if (!this.comments[postId]) {
      this.comments[postId] = [];
    }

    // Se Ã© uma resposta, adiciona ao comentÃ¡rio pai
    if (parentCommentId) {
      const parentComment = this.findComment(postId, parentCommentId);
      if (parentComment) {
        parentComment.replies.push(comment);
      } else {
        throw new Error('ComentÃ¡rio pai nÃ£o encontrado');
      }
    } else {
      // Adiciona como comentÃ¡rio principal
      this.comments[postId].push(comment);
    }

    this.saveComments();
    
    // Emite evento para sistema real-time
    this.emitCommentEvent('comment_added', {
      postId,
      comment,
      isReply: !!parentCommentId
    });

    return comment;
  }

  // Edita um comentÃ¡rio existente
  editComment(postId, commentId, newText, userId) {
    if (!newText?.trim()) {
      throw new Error('Novo texto Ã© obrigatÃ³rio');
    }

    const comment = this.findComment(postId, commentId);
    
    if (!comment) {
      throw new Error('ComentÃ¡rio nÃ£o encontrado');
    }

    if (comment.userId !== userId) {
      throw new Error('UsuÃ¡rio nÃ£o autorizado a editar este comentÃ¡rio');
    }

    // HistÃ³rico de ediÃ§Ãµes
    if (!comment.editHistory) {
      comment.editHistory = [];
    }
    
    comment.editHistory.push({
      text: comment.text,
      editedAt: comment.editedAt || comment.timestamp
    });

    comment.text = newText.trim();
    comment.edited = true;
    comment.editedAt = new Date().toISOString();

    this.saveComments();
    
    this.emitCommentEvent('comment_edited', {
      postId,
      commentId,
      newText: comment.text
    });

    return comment;
  }

  // Remove um comentÃ¡rio
  deleteComment(postId, commentId, userId, isAdmin = false) {
    const comment = this.findComment(postId, commentId);
    
    if (!comment) {
      throw new Error('ComentÃ¡rio nÃ£o encontrado');
    }

    if (comment.userId !== userId && !isAdmin) {
      throw new Error('UsuÃ¡rio nÃ£o autorizado a deletar este comentÃ¡rio');
    }

    // Soft delete - marca como deletado mas mantÃ©m estrutura para respostas
    comment.text = '[ComentÃ¡rio removido]';
    comment.isDeleted = true;
    comment.deletedAt = new Date().toISOString();
    comment.deletedBy = userId;

    this.saveComments();
    
    this.emitCommentEvent('comment_deleted', {
      postId,
      commentId,
      deletedBy: userId
    });

    return true;
  }

  // ObtÃ©m comentÃ¡rios de um post
  getComments(postId, options = {}) {
    const {
      limit = 50,
      offset = 0,
      sortBy = 'timestamp', // timestamp, likes, replies
      order = 'asc', // asc, desc
      includeReplies = true,
      hideDeleted = true
    } = options;

    let comments = this.comments[postId] || [];

    // Filtra comentÃ¡rios deletados se necessÃ¡rio
    if (hideDeleted) {
      comments = comments.filter(comment => !comment.isDeleted);
    }

    // OrdenaÃ§Ã£o
    comments = this.sortComments(comments, sortBy, order);

    // PaginaÃ§Ã£o
    comments = comments.slice(offset, offset + limit);

    // Processa respostas se necessÃ¡rio
    if (includeReplies) {
      comments = comments.map(comment => ({
        ...comment,
        replies: this.sortComments(comment.replies || [], sortBy, order)
      }));
    }

    return comments;
  }

  // Busca comentÃ¡rios por texto
  searchComments(postId, searchTerm, options = {}) {
    const comments = this.getComments(postId, { ...options, includeReplies: true });
    const results = [];

    const searchInComment = (comment) => {
      if (comment.text.toLowerCase().includes(searchTerm.toLowerCase())) {
        results.push(comment);
      }
      
      // Busca nas respostas
      if (comment.replies) {
        comment.replies.forEach(searchInComment);
      }
    };

    comments.forEach(searchInComment);
    return results;
  }

  // ObtÃ©m estatÃ­sticas de comentÃ¡rios
  getCommentStats(postId) {
    const comments = this.comments[postId] || [];
    
    const stats = {
      total: 0,
      totalWithReplies: 0,
      topCommenters: {},
      avgCommentsPerUser: 0,
      mostLikedComment: null,
      mostRepliedComment: null,
      recentActivity: []
    };

    const processComment = (comment) => {
      if (!comment.isDeleted) {
        stats.total++;
        stats.totalWithReplies++;
        
        // Contagem por usuÃ¡rio
        stats.topCommenters[comment.userId] = (stats.topCommenters[comment.userId] || 0) + 1;
        
        // ComentÃ¡rio mais curtido
        if (!stats.mostLikedComment || comment.likes > stats.mostLikedComment.likes) {
          stats.mostLikedComment = comment;
        }
        
        // ComentÃ¡rio com mais respostas
        const replyCount = comment.replies ? comment.replies.length : 0;
        if (!stats.mostRepliedComment || replyCount > (stats.mostRepliedComment.replies?.length || 0)) {
          stats.mostRepliedComment = comment;
        }
        
        // Atividade recente (Ãºltimos 7 dias)
        const commentDate = new Date(comment.timestamp);
        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        if (commentDate > weekAgo) {
          stats.recentActivity.push(comment);
        }
      }
      
      // Processa respostas
      if (comment.replies) {
        comment.replies.forEach(processComment);
      }
    };

    comments.forEach(processComment);
    
    // Calcula mÃ©dia
    const uniqueUsers = Object.keys(stats.topCommenters).length;
    stats.avgCommentsPerUser = uniqueUsers > 0 ? stats.totalWithReplies / uniqueUsers : 0;
    
    return stats;
  }

  // Reporta um comentÃ¡rio
  reportComment(postId, commentId, userId, reason) {
    const comment = this.findComment(postId, commentId);
    
    if (!comment) {
      throw new Error('ComentÃ¡rio nÃ£o encontrado');
    }

    if (!comment.reports) {
      comment.reports = [];
    }

    // Verifica se usuÃ¡rio jÃ¡ reportou
    const existingReport = comment.reports.find(r => r.userId === userId);
    if (existingReport) {
      throw new Error('UsuÃ¡rio jÃ¡ reportou este comentÃ¡rio');
    }

    comment.reports.push({
      userId,
      reason,
      timestamp: new Date().toISOString()
    });

    comment.reported = true;

    // Auto-hide se muitos reports
    if (comment.reports.length >= 3) {
      comment.isHidden = true;
    }

    this.saveComments();
    
    this.emitCommentEvent('comment_reported', {
      postId,
      commentId,
      reason,
      reportCount: comment.reports.length
    });

    return true;
  }

  // Modera comentÃ¡rio (para admins)
  moderateComment(postId, commentId, action, moderatorId) {
    const comment = this.findComment(postId, commentId);
    
    if (!comment) {
      throw new Error('ComentÃ¡rio nÃ£o encontrado');
    }

    const now = new Date().toISOString();

    switch (action) {
      case 'hide':
        comment.isHidden = true;
        comment.moderatedAt = now;
        comment.moderatedBy = moderatorId;
        break;
      case 'show':
        comment.isHidden = false;
        comment.moderatedAt = now;
        comment.moderatedBy = moderatorId;
        break;
      case 'delete':
        return this.deleteComment(postId, commentId, moderatorId, true);
      default:
        throw new Error('AÃ§Ã£o de moderaÃ§Ã£o invÃ¡lida');
    }

    this.saveComments();
    
    this.emitCommentEvent('comment_moderated', {
      postId,
      commentId,
      action,
      moderatorId
    });

    return comment;
  }

  // MÃ©todos auxiliares
  findComment(postId, commentId) {
    const comments = this.comments[postId] || [];
    
    for (const comment of comments) {
      if (comment.id === commentId) {
        return comment;
      }
      
      // Busca nas respostas
      if (comment.replies) {
        for (const reply of comment.replies) {
          if (reply.id === commentId) {
            return reply;
          }
        }
      }
    }
    
    return null;
  }

  sortComments(comments, sortBy, order) {
    const multiplier = order === 'desc' ? -1 : 1;
    
    return comments.sort((a, b) => {
      switch (sortBy) {
        case 'likes':
          return (a.likes - b.likes) * multiplier;
        case 'replies':
          return ((a.replies?.length || 0) - (b.replies?.length || 0)) * multiplier;
        case 'timestamp':
        default:
          return (new Date(a.timestamp) - new Date(b.timestamp)) * multiplier;
      }
    });
  }

  generateCommentId() {
    return 'comment_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }

  getDeviceInfo() {
    return {
      platform: navigator.platform,
      language: navigator.language,
      cookieEnabled: navigator.cookieEnabled,
      onLine: navigator.onLine
    };
  }

  getIpHash() {
    // SimulaÃ§Ã£o de hash de IP (em produÃ§Ã£o seria feito no backend)
    return 'ip_' + Math.random().toString(36).substr(2, 16);
  }

  emitCommentEvent(eventType, data) {
    // IntegraÃ§Ã£o com realTimeService
    if (window.realTimeService) {
      window.realTimeService.emit(eventType, {
        ...data,
        timestamp: new Date().toISOString()
      });
    }

    // Evento customizado para outros componentes
    window.dispatchEvent(new CustomEvent('commentUpdate', {
      detail: { eventType, ...data }
    }));
  }

  // Limpa comentÃ¡rios antigos (para manutenÃ§Ã£o)
  cleanupOldComments(daysOld = 90) {
    const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1000);
    let cleaned = 0;

    Object.keys(this.comments).forEach(postId => {
      this.comments[postId] = this.comments[postId].filter(comment => {
        const commentDate = new Date(comment.timestamp);
        if (commentDate < cutoffDate && comment.isDeleted) {
          cleaned++;
          return false;
        }
        return true;
      });
    });

    this.saveComments();
    return cleaned;
  }
}

// InstÃ¢ncia global do serviÃ§o
const commentService = new CommentService();

export default commentService;
